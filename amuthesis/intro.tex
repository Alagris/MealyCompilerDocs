
This project focuses on research in the field of automata theory and inductive inference.  The main product of our work is the "Solomonoff" regular expression compiler for finite state transducers. Plenty of research has gone into development of the theory behind this system. As a result the transducers contain several features not known before. 

The most innovative achievements is the lexicographic arctic semiring of weights\cite{MendozaDrosik2020MultitapeAA}, specialized adaptation of Glushkov's construction for subsequential transducers and the most significant flagship feature - built-in support for inductive inference and machine learning of transducers. Thanks to the cooperation with LearnLib and Dortmund University, Solomonoff supports learning algorithms such as RPNI and several of it's  derivatives. We contributed to LearnLib a specialized algorithm for inference of transducers. In particular we implemented OSTIA for efficient learning of deterministic transducers. For nondeterministic ones we developed our own OFTIA algorithm, which was not known before. Additionally we provide an alternative version of OSTIA extended with heuristic search.

All those features together make Solomonoff a unique library that stands out from the alternatives. We support most of the features of UNIX regexes. It's possible to achieve mechanics equivalent to those of look-aheads and look-behinds, which is unusual for automata-based regex engine. The key to Solomonoff 's expressiveness is the possibility of emulating look-aheads with careful placement of transducer outputs. As a result Solomonoff can compete and  do much more than existing projects such as RE2 developed by Google, BRICKS automata developed at Aarhus University or even to certain extent with Pearl/Java based regular expression engines. Another, much stronger competitor for Solomonoff is the OpenFST project developed by Google in collaboration with University of New York. There is a vast intersection of features supported by both libraries, although OpenFST puts heavy emphasis on probabilistic transducers, whereas Solomonoff has better support for formal verification and machine learning. Our project won't be a replacement for OpenFST in the foreseeable future but there are areas where Solomonoff performs better. This is particularly palpable in efficiency as indicated by several of our benchmarks.

Unlike most other automata libraries, Solomonoff's development focuses on the compiler and regular expressions instead of library API. Everything can be achieved without writing Java code. Such approach also allows the developers for much greater flexibility, because the internal implementation can be drastically changed at any time, without breaking existing regular expressions. The public API is minimalist. As a result backwards-compatibility is rarely an issue.  

Another feature of Solomonoff, which is uncommon among regular expression engines is its integrated build system. Our compiler was designed for large codebases consisting of multiple files with dependencies. Thrax is the only alternative that does have a "build system" but it's very primitive and relies on generating Makefiles. Solomonoff has a well integrated tool that assembles large projects, detects cyclic dependencies, allows for parallel compilation and performs additional code optimisations. 


Our project strives to make automata as easy to use and accessible to mass audiences as possible. For this reason we developed a website with online playground where visitors could test Solomonoff and experiment without any setup required. The backend technology we used is Spring Boot, because it allowed for convenient integration with existing API in Java. The website provides downloads of prepackaged JAR files as well as syntax highlighting rules for several popular text editors. 



To allow for easy experimentation and to lower the barrier of entry, Solomonoff comes with interactive shell. It allows for efficient and convenient work with the compiler from command-line interface, where local changes can be hot-swapped and reloaded on live compiler session. Developers could then test their regular expressions without the need to fully recompile their project. 

The REPL console can be easily and painlessly explored without local installation. The website comes with online version of compiler, which can be accessed from any major browser (IE not supported). Most of the command-line features can be used in the online environment, with a few exceptions of features specific only to locally-running instances (especially those allowing for saving and reading files). 

The online interface can serve as a user-friendly playground for newcomers. It is not meant to be a replacement for locally running compiler. Due to the necessity of communicating with backend server and limited computational resources shared among possibly large number of users, the online REPL has major performance limitations. The command-line interface has been designed and optimised with the purpose of providing high efficiency for codebases containing thousands of lines. It supports parallel compilation and caching of previously compiled units. 

Developers have the ability to modularise their projects. Precompiled automata can ve stored and loaded from packages. The build-system is capable of resolving dependencies.

