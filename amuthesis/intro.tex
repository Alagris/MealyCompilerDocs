
This project focuses on research in the field of automata theory and inductive inference.  The main product of our work is the "Solomonoff" regular expression compiler for finite state transducers. Plenty of research has gone into development of the theory behind this system. As a result the transducers contain several features not known before. 

The most innovative achievements is the lexicographic arctic semiring of weights, specialized adaptation of Glushkov's construction for subsequential transducers and the most significant flagship feature - built-in support for inductive inference and machine learning of transducers. Thanks to the cooperation with LearnLib and Dortmund University, Solomonoff supports learning algorithms such as RPNI and several of it's  derivatives. We contributed to LearnLib a specialized algorithm for inference of transducers. In particular we implemented OSTIA for efficient learning of deterministic transducers. For nondeterministic ones we developed our own OFTIA algorithm, which was not known before. Additionally we provide an alternative version of OSTIA extended with heuristic search.

All those features together make Solomonoff a unique library that stands out from the alternatives. We support most of the features of UNIX regexes. It's possible to achieve mechanics equivalent to those of look-aheads and look-behinds, which is unusual for automata-based regex engine. The key to Solomonoff 's expressiveness is the possibility of emulating look-aheads with careful placement of transducer outputs. As a result Solomonoff can compete and  do much more than existing projects such as RE2 developed by Google, BRICKS automata developed at Aarhus University or even to certain extent with Pearl/Java based regular expression engines. Another, much stronger competitor for Solomonoff is the OpenFST project developed by Google in collaboration with University o New York. Their Thrax grammars are capable of doing most of the things that Solomonoff can and they also support probabilistic automata. OpenFST is much older and more established in the scientific community. They support a lot more features that were developed by scientists over the course of many years. Solomonoff cannot compete with this level of sophistication, but perhaps, what might seem like a limitation, is in fact our strongest advantage. Solomonoff focuses on functional transducers and enforces this property at compilation time. Any arising nondeterministic output is automatically rejected as an error. This allows Solomonoff to perform a lot more optimisations, the automata are smaller and their behaviour is more predictable. Moreover, lexicographic weights allow for precise disambiguation of nondeterministic paths whenever necessary and their most important advantage is that lexicographic semiring is not commutative and hence it does not "propagate" throughout entire automaton. Those traits increase Solomonoff's robustness and allows for (exponentially) smaller automata, without sacrificing predictability of the regular expression. On th contrary, probabilistic weights in Thrax, make the whole system, more heavyweight, unpredictable and difficult to maintain. The results are especially palpable when comparing our benchmarks. Solomonoff was written in Java and Thrax uses C++, but despite this our compiler is several magnitudes more efficient. OpenFST uses epsilon transitions, while Solomonoff does not implement them and instead all automata are always and directly produced in epsilon-free form. OpenFST performs operations such as sorting of edges, determinization, epsilon-removal and minimization. Solomonoff always has all of its edges sorted, hence a dedicate routine for epsilon-removal is unnecessary. The compilation produces small automata without performing minimisation. The user can optionally further compress transducers determinization using pseudo-minimisation algorithm for nondeterministic transducers, which is based on heuristics inspired by Kameda-Weiner's NFA minimization. 

Unlike most other automata libraries, Solomonoff's development focuses on the compiler and regular expressions instead of library API. Everything can be achieved without writing Java code. Such approach also allows the developers for much greater flexibility, because the internal implementation can be drastically changed at any time, without breaking existing regular expressions. The public API is minimalist. As a result backwards-compatibility is rarely an issue.  

Another feature of Solomonoff, which is uncommon among regular expression engines is its integrated build system. Our compiler was designed for large codebases consisting of multiple files with dependencies. Thrax is the only alternative that does have a "build system" but it's very primitive and relies on generating Makefiles. Solomonoff has a well integrated tool that assembles large projects, detects cyclic dependencies, allows for parallel compilation and performs additional code optimisations. 


Our project strives to make automata as easy to use and accessible to mass audiences as possible. For this reason we developed a website with online playground where visitors could test Solomonoff and experiment without any setup required. The backend technology we used is Spring Boot, because it allowed for convenient integration with existing API in Java. The website provides downloads of prepackaged JAR files as well as syntax highlighting rules for several popular text editors. 



To allow for easy experimentation and to lower the barrier of entry, Solomonoff comes with interactive shell. It allows for efficient and convenient work with the compiler from command-line interface, where local changes can be hot-swapped and reloaded on live compiler session. Developers could then test their regular expressions without the need to fully recompile their project. 

The REPL console can be easily and painlessly explored without local installation. The website comes with online version of compiler, which can be accessed from any major browser (IE not supported). Most of the command-line features can be used in the online environment, with a few exceptions of features specific only to locally-running instances (especially those allowing for saving and reading files). 

The online interface can serve as a user-friendly playground for newcomers. It is not meant to be a replacement for locally running compiler. Due to the necessity of communicating with backend server and limited computational resources shared among possibly large number of users, the online REPL has major performance limitations. The command-line interface has been designed and optimised with the purpose of providing high efficiency for codebases containing thousands of lines. It supports parallel compilation and caching of previously compiled units. 

Developers have the ability to modularise their projects. Precompiled automata can ve stored and loaded from packages. The build-system is capable of resolving dependencies.

